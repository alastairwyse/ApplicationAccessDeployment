#
# Copyright 2025 Alastair Wyse 
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#

#
# NAME
#     application_access_docker_build.py
#
# SYNOPSIS
#     Creates a docker images from a set of ApplicationAccess component tar files and pushes those images to docker hub.
#
# SYNTAX
#     application_access_docker_build.py [tar folder path] [dockerhub namespace] [dockerhub tag] [push to dockerhub]
#
# EXAMPLES
#     python3 application_access_docker_build.py "/home/user/ApplicationAccessDocker/Tars" "myreponame" "20251219-1411" Y
#
# NOTES / TODO
#     Requires that the 'docker' process has been previously connected to and authenticated against a docker repository.
#

from abc import ABC, abstractmethod
from datetime import datetime
from typing import List
from subprocess import CalledProcessError
import os, sys, subprocess

class OperatingSystemMethodShims(ABC):
    """Defines shims for methods which interract with the operating system."""

    @abstractmethod
    def execute_operating_system_command(self, command: str, base_directory: str) -> List[str]:
        """Executes a specified command against the operating system, returning any stdout generated by the command.

        Args:
            command: 
                The command to execute.
            base_directory:
                The base directory to execute the command from.
                
        Returns:
            The stdout generated by the command as a list of strings.
        """


class DefaultOperatingSystemMethodShims(OperatingSystemMethodShims):
    """Default implementation of OperatingSystemMethodShims."""

    def execute_operating_system_command(self, command: str, base_directory: str) -> List[str]:
        
        try:
            stdout: str = subprocess.check_output(command, cwd=base_directory, shell=True, text=True)
        except Exception as exc:
            raise Exception("Failed to execute command '{0}'.".format(command)) from exc
        result_lines: List[str] = stdout.splitlines()

        return result_lines


def get_script_file_name() -> str:
    """Returns the name of this file."""
    script_file_path: str = __file__

    return script_file_path.split("/").pop()


def print_usage_message() -> None:
    """Prints a 'usage' message to the console."""
    print("USAGE: ")
    print("  {0} [tar folder path] [dockerhub namespace] [dockerhub tag] [push to dockerhub]".format(get_script_file_name()))
    print()


def get_docker_image_tag_from_stdout(docker_build_stdout: str) -> str:
    """Extracts and returns a docker image tag from the stdout produced by the 'docker build' command.

        Args:
            docker_build_stdout: 
                The last line of the stdout produced by the 'docker build' command.
                
        Returns:
            The docker image tag.
    """
    stdout_expected_prefix: str = "Successfully built "
    if (docker_build_stdout[0: len(stdout_expected_prefix)] != stdout_expected_prefix):
        raise Exception("Docker build command stdout '{0}' was expected to be prefixed with '{1}'.".format(docker_build_stdout, stdout_expected_prefix))
    
    return docker_build_stdout[len(stdout_expected_prefix): ]


def execute_docker_build() -> None:
    # Read parameters from the command line
    expected_command_line_parameter_count: int = 4
    if (len(sys.argv) != expected_command_line_parameter_count + 1):
        print_usage_message()
        raise Exception("Received unexpected number of command line parameters.  Expected {0}, but received {1}.".format(expected_command_line_parameter_count, len(sys.argv) - 1))
    tar_folder_path: str = sys.argv[1]
    dockerhub_namespace: str = sys.argv[2]
    dockerhub_tag: str = sys.argv[3]
    push_to_dockerhub_string: str = sys.argv[4]

    # Validate the command line parameters
    if (os.path.isdir(tar_folder_path) == False):
        print_usage_message()
        raise Exception("Tar folder path '{0}' does not exist.".format(tar_folder_path))
    dockerhub_tag_valid: bool = False
    if (len(dockerhub_tag) == 13):
        if (dockerhub_tag[8] == "-"):
            dockerhub_tag_no_dash: str = dockerhub_tag.replace("-", "")
            try:
                datetime.strptime(dockerhub_tag, "%Y%m%d-%H%M")
                dockerhub_tag_valid = True
            except ValueError:
                pass
    if (dockerhub_tag_valid == False):
        print_usage_message()
        raise Exception("Dockerhub tag '{0}' must be specified in format 'YYYYMMDD-HH:MI'.".format(dockerhub_tag))
    if (not ((push_to_dockerhub_string.lower() == "y") or (push_to_dockerhub_string.lower() == "n"))):
        print_usage_message()
        raise Exception("Push to dockerhub parameter '{0}' is invalid.  Valid values are 'y', 'Y', 'n', or 'N'.".format(push_to_dockerhub_string))
    push_to_dockerhub: bool = True
    if (push_to_dockerhub_string.lower() == "n"):
        push_to_dockerhub: bool = False


    # Delete any subfolders from the tar folder
    command_executor = DefaultOperatingSystemMethodShims()
    command_executor.execute_operating_system_command("cd {0}".format(tar_folder_path), tar_folder_path)
    subfolders: List[str] = list()
    try:
        subfolders = command_executor.execute_operating_system_command("ls -d */ -1", tar_folder_path)
    except Exception as exc:
        subfolders_exist: bool = True
        if (exc.__cause__ is not None):
            if (type(exc.__cause__) == CalledProcessError):
                if (exc.__cause__.returncode == 2):
                    subfolders_exist = False
        if (subfolders_exist == True):
            raise
    for current_subfolder in subfolders:
        command_executor.execute_operating_system_command("rm -r {0}".format(current_subfolder), tar_folder_path)
    
    # Untar each of the tar files
    tar_files: List[str] = command_executor.execute_operating_system_command("ls *.tar -1", tar_folder_path)
    for current_tar_file in tar_files:
        current_tar_file_without_extension: str = current_tar_file.split(".")[0]
        command_executor.execute_operating_system_command("mkdir {0}".format(current_tar_file_without_extension), tar_folder_path)
        command_executor.execute_operating_system_command("tar -C ./{0} -xf {1}".format(current_tar_file_without_extension, current_tar_file), tar_folder_path)

    # Build each docker image and upload to dockerhub
    for current_tar_file in tar_files:
        current_tar_file_without_extension: str = current_tar_file.split(".")[0]
        print("Building and pushing docker image for component '{0}'...".format(current_tar_file_without_extension))
        docker_build_stdout: List[str] = command_executor.execute_operating_system_command("docker build {0}/".format(current_tar_file_without_extension), tar_folder_path)
        docker_image_tag: str = get_docker_image_tag_from_stdout(docker_build_stdout.pop())
        new_tag: str = "{0}/{1}:{2}".format(dockerhub_namespace, current_tar_file_without_extension.lower(), dockerhub_tag)
        command_executor.execute_operating_system_command("docker tag {0} {1}".format(docker_image_tag, new_tag), tar_folder_path)
        if (push_to_dockerhub == True):
            command_executor.execute_operating_system_command("docker push {0}".format(new_tag), tar_folder_path)
            command_executor.execute_operating_system_command("docker image rm {0}".format(docker_image_tag), tar_folder_path)
            print("Successfully pushed tag '{0}'.".format(new_tag))
        else:
            print("Successfully built image '{0}'.".format(new_tag))            

    print("SUCCESS: Completed Docker build process.")


execute_docker_build()